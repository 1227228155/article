# 第十三章 事件

> JS与HTML之间的交互是通过事件交互的

## 13.1 事件流

### 13.1.1事件冒泡

事件开始时由最具体的元素接收，然后逐级向上传播

例：click div

 ![0825](js\img\0825.png)

### 13.1.2 事件捕获

例：click div

 ![0825-1](js\img\0825-1.png)

> 优先使用冒泡，由特殊需要时再使用事件捕获

### 13.1.3 DOM事件流

 ![0825-2](js\img\0825-2.png)

1、2、3事件捕获阶段；4处于目标阶段；5、6、7冒泡阶段（4在事件处理中被看成冒泡阶段的一部分）

## 13.2 事件处理程序

> 响应某个事件的函数叫做事件处理程序

### 13.2.1 HTML事件处理程序

```html
<input type="button" id="" value="click" onclick="alert()"/>
```

和号（）、双引号（）、小于号（）或大于号（）注意注意转义

```html
<input type="button" id="" value="click" onclick="showMsg()"/>
<script type="text/javascript">
	function showMsg () {
		alert();
	}
</script>
```

```html
//event
<input type="button" id="" value="click" onclick="alert(event.type)"/>
```

```html
//this
<input type="button" id="" value="clicks" onclick="this.value"/>
<input type="button" id="" value="clicks" onclick="value"/>
```

```html
<form action="">
	<input type="text" id="" value="aa" name="a"/>
	<input type="button" id="" value="bb" name="b" onclick="alert(a.value)"/>
</form>
```

在HTML中指定事件处理程序的缺点：

1、存在时差问题。不具有执行条件却被执行；

2、浏览器之间的执行差异；

3、HTML与JS代码紧密耦合。

### 13.2.2 DOM0级事件处理程序

```js
//DOM0
//冒泡阶段被处理
var btn = document.getElementById('myBtn');
btn.onclick = function() {
	alert(this.id); //myBtn
};
//删除
btn.onclick = null;
```

### 13.2.3 DOM2级事件处理程序

`addEventListener()`、`removeEventListener()`

```js
//DOM2
var btn = document.getElementById('myBtn');
btn.addEventListener('click', function() { //ie9+
	alert(this.id);
}, false);
```

> 可设置一布尔值为第三个参数，`true`为捕获阶段处理、`false`为冒泡阶段处理，默认为`false`

```js
//可绑定多个事件
var btn = document.getElementById('myBtn');
btn.addEventListener('click', function() {
	alert(this.id);
}, false);
btn.addEventListener('click', function() {
	alert('hello');
}, false);
```

```js
var btn = document.getElementById('myBtn');
btn.addEventListener('click', function() {
	alert(this.id);
}, false);
btn.removeEventListener('click', function() { //没有用，需要函数名
	alert(this.id);
}, false);
```

```js
var btn = document.getElementById('myBtn');
var handler = function() {
	alert(this.id);
};
btn.addEventListener('click', handler, false);
btn.removeEventListener('click', handler, false); //有用了
```

### 13.2.4 IE事件处理程序

```js
//ie5-10only
var btn = document.getElementById('myBtn');
btn.attachEvent('onclick', function() {
	alert();
});
```

作用域与DOM0级方法有区别

```js
var btn = document.getElementById('myBtn');
btn.attachEvent('onclick', function() {
	alert(this === window); //true，DOM0级方法中为局部作用域
});
```

```js
//添加多个事件处理程序
var btn = document.getElementById('myBtn');
btn.attachEvent('onclick', function() {
	alert(1);
});
btn.attachEvent('onclick', function() {
	alert(2);
});
```

```js
//移除事件处理程序
var btn = document.getElementById('myBtn');
var handler = function() {
	alert(this.id);
};
btn.attachEvent('click', handler);
btn.detachEvent('click', handler);
```

### 13.2.5 跨浏览器的事件处理程序

```js
//跨浏览器
var EventUtil = {
	addHandler: function(element, type, handler) {
		if(element.addEventListener) {
			element.addEventListener(type, handler, false);
		} else if(element.attachEvent) {
			element.attachEvent('on' + type, handler);
		} else {
			element['on' + type] = handler;
		}
	},
	removeHandler: function(element, type, handler) {
		if(element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if(element.detachEvent) {
			element.detachEvent('on' + type, handler);
		} else {
			element['on' + type] = null;
		}
	}
};
```

```js
//例子
var btn = document.getElementById('myBtn');
var handler = function() {
	alert(this.id);
};
EventUtil.addHandler(btn, 'click', handler);
EventUtil.removeHandler(btn, 'click', handler);
```

> 这里还有作用域不一致的问题，要注意；另外DOM0级每个事件只支持一个处理程序。

## 13.3 事件对象

`event` 触发事件时产生的事件对象，包含着所有与事件有关的信息

### 13.3.1 DOM中的事件对象

| 属性/方法                      | 类型           | 读/写  | 说明                                       |
| -------------------------- | ------------ | ---- | ---------------------------------------- |
| bubbles                    | Boolean      | 只读   | 表明事件是否冒泡                                 |
| cancelabel                 | Boolean      | 只读   | 表明是否可以取消事件的默认行为                          |
| currentTarget              | Element      | 只读   | 其事件处理程序当前正在处理事件的那个元素                     |
| defaultPrevented           | Boolean      | 只读   | 为true表示已经调用了preventDefault()（DOM3）       |
| detail                     | Integer      | 只读   | 与事件相关的细节信息                               |
| eventPhase                 | Integer      | 只读   | 调用事件处理程序的阶段：1表示捕获阶段，2表示‘处于目标’，3表示冒泡阶段    |
| preventDefault()           | Function     | 只读   | 取消事件的默认行为。如果cancelabel是true，则可以使用这个方法    |
| stopImmediatePropagation() | Function     | 只读   | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3）      |
| stopPropagation()          | Function     | 只读   | 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法   |
| target                     | Element      | 只读   | 事件的目标                                    |
| trusted                    | Boolean      | 只读   | 为true表示事件是浏览器生成的。为false表示是由开发人员通过js创建的（DOM3） |
| type                       | String       | 只读   | 被触发的事件的类型                                |
| view                       | AbstractView | 只读   | 与事件关联的抽象视图。等同于发生事件的window对象              |

```js
var btn = document.getElementById('myBtn');
btn.onclick = function(event) {
	alert(event.currentTarget === this); //true
	alert(event.target === this); //true
};

document.body.onclick = function(event) {
	alert(event.currentTarget === document.body); //true
	alert(this = document.body); //true
	alert(event.target === document.getElementById('myBtn')); //true
}
```

```js
//一个函数处理多个事件
var btn = document.getElementById('myBtn');
var handler = function(event) {
	switch(event.type) {
		case 'click':
			alert('c');
			break;
		case 'mouseover':
			event.target.style.backgroundColor = 'red';
			break;
		case 'mouseout':
			event.target.style.backgroundColor = '';
			break;
	}
};

btn.onclick = handler;
btn.onmouseover = handler;
btn.onmouseout = handler;
```

```js
var link = document.getElementById('myLink');
link.onclick = function(event) {
	event.preventDefault();//阻止默认行为，需要cancelabel是true
	event.stopPropagation();//阻止冒泡
	alert(event.eventPhase);//确定事件处理程序的阶段
};
```

### 13.3.2 IE中的事件对象

下一节见

### 13.3.3 跨浏览器的事件对象

```js
var EventUtil = {
	//省略之前的
	getEvent: function(event) {
		return event ? event : window.event;
	},
	getTarget: function(event) {
		return event.target || event.srcElement;
	},
	preventDefault: function(event) {
		if(event.preventDefault) {
			event.preventDefault();
		} else {
			event.returnValue = false;
		}
	},
	removeHandler: function(element, type, handler) {
		if(element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if(element.detachEvent) {
			element.detachEvent('on' + type, handler);
		} else {
			element['on' + type] = null;
		}
	},
	stopPropagation: function(event) {
		if(event.stopPropagation) {
			event.stopPropagation();
		} else {
			event.cancelable = true;
		}
	}
};
```

```js
//例子
btn.onclick = function(event) {
	event = EventUtil.getEvent(event); //传event
	var target = EventUtil.getTarget(event); //传target	
	EventUtil.stopPropagation(event); //阻止冒泡
};
var link = document.getElementById('myLink');
link.onclick = function(event) {
	event = EventUtil.getEvent(event);
	EventUtil.preventDefault(event); //阻止默认行为
};
```

## 13.4 事件类型

